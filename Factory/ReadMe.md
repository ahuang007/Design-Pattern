
## 问题

* 在面向对象系统设计中经常可以遇到以下的两类问题:
	
1. 为了提高内聚(Cohesion)和松耦合(Coupling)，我们经常会抽象出一些类的公共接口以形成抽象基类或者接口。这样我们可以通过声明一个指向基类的指针来指向实际的子类实现，达到了多态的目的。这里很容易出现的一个问题n多的子类继承自抽象基类，我们不得不在每次要用到子类的地方就编写诸如 `new XXX;` 的代码。这里带来两个问题：
	1. 客户程序员必须知道实际子类的名称(当系统复杂后，命名将是一个很不好处理的问题，为了处理可能的名字冲突，有的命名可能并不能具有很好的可读性和可记忆性，就姑且不论不同程序员千奇百怪的个人偏好了。
	2. 程序的扩展性和维护变得越来越困难。
	
2. 还有一种情况就是在父类中并不知道具体要实例化哪一个具体的子类。这里的意思为：假设我们在类 A 中要使用到类 B,B 是一个抽象父类，在 A 中并不知道具体要实例化哪一个B的子类，但是在类 A 中的子类 D 中是可以知道的。在 A 中我们没有办法直接使用类似于 `new XXX;` 的语句，因为根本就不知道 XXX 是什么。

* 以上两个问题也就引出了 Factory 模式的两个最重要的功能：

1. 定义创建对象的接口，封装了对象的创建；
2. 使得具体化类的工作延迟到了子类中。

## 模式选择

* 我们通常使用 Factory 模式来解决上面给出的两个问题。
	- 在第一个问题中，我们经常就是声明一个创建对象的接口，并封装了对象的创建过程。Factory 这里类似于一个真正意义上的工厂（生产对象）。
	- 在第二个问题中，我们需要提供一个对象创建对象的接口，并在子类中提供其具体的实现（因为只有在子类中可以决定到底实例化哪一个子类）。
	
	
## 代码说明

* 示例代码中给出的是 Factory 模式解决父类中并不知道具体实例化哪一个具体的子类的问题，至于为创建对象提供接口问题，可以由 Factory 中附加相应的创建操作 例如 `Create***Product()` 即可 

## 讨论
	Factory 模式在实际开发中应用非常广泛，面向对象的系统经常面临着对象创建问题：要创建的类实在是太多了。而 Factory 提供的创建对象的接口封装（第一个功能），以及其讲类的实例化推迟到了子类（第二个功能）都部分地解决了实际问题。
	Factory 模式也带来了以下两个问题：
	1. 如果为每一个具体的 ConcreteProduct 类的实例化提供一个函数体，那么我们可能不得不在系统中添加一个方法来处理这个新建的 ConcreteProduct，这样 Factory 的接口永远就不可能封闭(Close)。当然我们可以通过创建一个 Factory 的子类来通过多态实现这一点，但是这也是以新建一个类作为代价的。
	2. 在实现中我们可以通过参数化工厂方法，即给 `FactoryMethod()` 传递一个参数用以决定是创建哪一个具体的 Product。当然也可以通过模板化避免 1 中的子类创建子类，其方法就是讲具体 Product 类作为模板参数，实现起来 也很简单。
	
	可以看出，Factory 模式对于对象的创建给予开发人员提供了很好的实现策略，但是 Factory 模式仅仅局限于一类类（就是说 Product 是一类，有一个共同的基类），如果我们要为不同的类提供一个对象创建的接口，那么就要用到 AbstractFactory 了。