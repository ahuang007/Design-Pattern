
# Command 模式

## 问题

* Command 模式通过将请求封装打一个对象（Command）中，并将请求的接受者存放到具体的 ConcreteCommand 类（Receiver）中，从而实现调用操作的对象和操作的具体实现者之间的解耦。

## 代码说明

* Command 模式的实现和思想都很简单，其关键 就是将一个请求封装到一个类中（Command），再提供处理对象（Receiver），最后 Command 命令由 Invoker 激活。另外，我们可以将请求者的处理抽象出来作为参数传给 Command 对象，实际也就是回调的机制（Callback）来实现实现这一点，也就是说将处理操作方法地址（在对象内部）通过参数传递给 Command 对象，Command 对象在适当的时候（Invoke 激活的时候）再调用该函数。这里就是要用到 c++ 中的类成员函数指针的概念。


## 讨论

* Command 模式的思想非常简单，但是 Command 模式也十分常见，并且威力不小。实际上，Command 模式关键就是提供一个抽象的 Command 类，并将执行操作封装到 Command 类接口中， Command 类中一般就是只是一些接口的集合，并不包含任何的数据属性（当然在示例代码中，我们的 Command 类有一个处理操作的 Receiver 类的引用，但是其作用也仅仅是为了实现这个 Command 的 Excute 接口）。这种方式在死纯正的面向对象设计者最为鄙视的设计方式，就像 OO 设计新手做系统设计的时候，仅仅将 Class 作为一个关键字，将 C 种的全局函数找一个类封装起来就以为是完成了面向对象的设计。

* 但是世界上的事情不是绝对的，上面提到的方式在 OO 设计中绝大部分的时候可能是一个不成熟的体现，但是 Command 模式中却是起到了很好的效果。主要体现在：

	1. Command 模式将调用操作的对象和知道如何实现该操作的对象解耦。在上面 Command 的结构图中，Invoker 对象根本就不知道具体的是哪个对象在处理 Excute 操作（当然要知道是 Command 类别的对象，也仅此而已）。
	2. 在 Command 要增加新的处理操作对象很容易，我们可以通过创建新的继承自 Command 的子类来实现这一点。
	3. Command 模式可以和 Memento 模式结合起来，支持取消的操作。