
# Bridge 模式

## 问题

* 总结面向对象实际上就两句话：一是低耦合（Coupling），一是高内聚（Cohesion）。面向对象系统追求的目标就是尽可能的提高系统模块内部的内聚（Cohesion）、尽可能降低模块间的耦合（Coupling）。然而这也是面向对象设计过程中最难把握的部分，大家肯定在 OO 系统的开发过程中遇到这样的问题：
	1. 客户给了你一个需求。于是使用一个类来实现（A）；
	2. 客户需求变化，有两个算法实现功能，于是改变设计，我们通过一个抽象的基类，再定义两个具体类实现两个不同的算法（A1 和 A2）；
	3. 客户又告诉我们说对于不同的操作系统，于是再抽象一个层次，作为一个抽象基类A0，再分别在每个操作系统派生具体类（A00 和 A01，其中 A00 表示原来的类A）实现不同操作系统上的客户需求，这样我们 就有了一共4个类。
	4. 可能用户的需求又变化了，比如说又有了一种新的算法。。。
	5. 我们陷入了一个需求变化的郁闷当中，也因此带来了类的迅速膨胀。
	Bridge 模式则正是解决了这类问题。
	
## 代码说明

* Bridge 模式将抽象和实现分别独立实现，在代码中就是 Abstraction 类和 AbstractionImp 类。

## 讨论

* Bridge 模式是设计模式中比较复杂和难以理解的模式之一，也是OO开发与设计中经常 会遇到的模式之一。使用组合（委托）的方式将抽象和实现彻底的解耦，这样的好处是抽象和实现可以分别独立的变化，系统的耦合性也得到了很好的降低。

* GoF 在说 Bridge 模式时，在意图中指出 Bridge 模式“将抽象部分与它的实现部分分离，使得它们可以独立的变化”。这句话很简单，但是也很复杂，连 Bruce Eckel 在他的大作《Thinking in Patterns》中说“Bridge 模式是 GoF 所讲述得最不好（Poorly-described）的模式”，个人觉得也正是如此。原因就在于 GoF 的那句话中的“实现”就是“抽象”的 具体子类的实现，但是这里 GoF 所谓的“实现”的含义不是指抽象基类的具体子类对抽象基类中虚函数（接口）的实现，是和继承集合在一起的。而这里的“实现”的含义指的是怎么去实现用户的需求，并不是指的通过组合（委托）的方式实现的，因此这里的实现不是指的继承基类、实现基类接口，而是指的是通过对象组合实现用户的需求。理解了这一点也就理解了 Bridge 模式，理解了 Bridge 模式，你的设计就会更加 Elegant 了。

* 实际上上面使用 Bridge 模式和使用带来问题方式的解决方案的根本区别是在于通过集成还是通过组合的方式去实现一个功能需求。因此面向对象分析和设计中有一个原则就是：Favor Composition Over Inheritance。其原因也正在这里。




